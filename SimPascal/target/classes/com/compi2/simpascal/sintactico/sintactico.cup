package com.compi2.simpascal.sintactico;

import com.compi2.simpascal.instrucciones.*;
import com.compi2.simpascal.instrucciones.operadores.OpAritmeticos;
import com.compi2.simpascal.instrucciones.simbolos.Simbolo;
import com.compi2.simpascal.instrucciones.tipos.*;
import java.util.LinkedList;
import java.util.HashMap;
import java_cup.runtime.*;

// parser
parser code {:
    public LinkedList<Errores> listaErrores = new LinkedList<>();
    public LinkedList<Instrucciones> extras = new LinkedList<>();

                public void syntax_error(Symbol s){
                    listaErrores.add(new Errores("SINTACTICO RECUPERABLE", "No se esperaba el componente "+s.value, s.left, s.right));
                }

                public void unrecovered_syntax_error (Symbol s){
                    listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE", "No se esperaba el componente " + s.value, s.left, s.right));
                }
:}

action code
{:
:}

//terminales

terminal String                         CADENA, ENTERO, DECIMAL, ID, COMA, PUNTOCOMA, PUNTO, DOSPUNTOS;
terminal char                           CARACTER;
terminal                                ARRAY, BEGIN, BOOLEAN, CHAR, CONST, DOWNTO, DO, ELSE, END,
                                        FILE, FOR, FUNCTION, GOTO, IF, IN, INTEGER, LABEL,
                                        NIL, OF, ON, PACKED, PROCEDURE, PROGRAM, READLN, REAL,
                                        RECORD, REPEAT, SET, STRING, THEN, TO, TYPE, UNTIL, VAR, WHILE, WITH, WRITELN;
terminal                                MAS, MENOS, MULTI, DIV, MOD, UMENOS, ASIGNACION;
terminal                                IGUALA, DIFERENTEA, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
terminal                                L_LLAVE, R_LLAVE, L_PAREN, R_PAREN, L_CORCH, R_CORCH, FLECHA, BARRA;
terminal                                OR, AND, NOT;


//no terminales

nonterminal LinkedList<Instruccion>     inicio, instrucciones;
nonterminal Instruccion                 instruccion;

nonterminal Tipo                        tipos;
nonterminal Instruccion                 expresion, e_arit, e_logic, e_relac, e_nativ, casteo;
nonterminal LinkedList<Instruccion>     i_declaracion;
nonterminal Instruccion                 i_write, i_asignar;
nonterminal Instruccion                 dec_const, dec_var;
nonterminal Simbolo                     constante;
nonterminal LinkedList<Simbolo>         constantes_list;
nonterminal LinkedList<String>          variable;
nonterminal int[2]                      rango;
nonterminal HashMap<LinkedList<String>, Tipo>  variables_list, var_aux;
nonterminal LinkedList<Instruccion>     write_aux;



precedence left     OR;
precedence left     AND;
precedence right    NOT;
precedence left     IGUALA, DIFERENTEA, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
precedence left     MAS, MENOS;
precedence left     MULTI, DIV, MOD;
precedence right    UMENOS;

start with inicio;

inicio  ::= PROGRAM ID i_declaracion:a BEGIN instrucciones:b END PUNTO        {:  RESULT = new LinkedList<>(); RESULT.addAll(a); RESULT.addAll(b); if(!extras.isEmpty()) { RESULT.addAll(extras); }:}
;

instrucciones   ::= instrucciones:a instruccion:b       {:  
                                                            RESULT = a; 
                                                            RESULT.add(b);
                                                        :}
                |   instruccion:a                       {:  
                                                            RESULT = new LinkedList<>(); 
                                                            RESULT.add(a);
                                                        :}
;

instruccion ::= i_write:a       {:  RESULT = a; :}
            |   i_asignar:a     {:  RESULT = a; :}
;

tipos   ::= INTEGER       {:  RESULT = new Tipo(Dato.ENTERO);     :}
        |   REAL          {:  RESULT = new Tipo(Dato.DECIMAL);    :}
        |   CHAR          {:  RESULT = new Tipo(Dato.CARACTER);   :}
        |   STRING        {:  RESULT = new Tipo(Dato.CADENA);     :}
        |   BOOLEAN       {:  RESULT = new Tipo(Dato.BOOLEANO);   :}
;

i_write   ::= WRITELN L_PAREN write_aux:a R_PAREN PUNTOCOMA     {:  RESULT = new WriteLn(a, aleft, aright); :}
;

write_aux   ::= write_aux:a COMA expresion:b        {:  
                                                        RESULT = a; 
                                                        RESULT.add(b);
                                                    :}
            |   expresion:a                         {:  
                                                        RESULT = new LinkedList<>(); 
                                                        RESULT.add(a);
                                                    :}
;

i_declaracion ::= dec_const:a dec_var:b        {: RESULT = new LinkedList<>(); RESULT.add(a); RESULT.add(b); :}
               | dec_const:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
               | dec_var:b                     {: RESULT = new LinkedList<>(); RESULT.add(b); :}
               | /* vac√≠o */                   {: RESULT = new LinkedList<>(); listaErrores.add(new Errores("SINTACTICO RECUPERABLE", "Error en la declaracion", 0, 0)); :}
;


dec_const ::= CONST constantes_list:a PUNTO        {: RESULT = new DecConst(a, aleft, aright); :}
;
constantes_list ::= constantes_list:a  constante:b {: RESULT = a; RESULT.add(b); :}
                  | constante:a  {: RESULT = new LinkedList<>(); RESULT.add(a);:}
;
constante ::= ID:a IGUALA expresion:b PUNTOCOMA   {: RESULT = new Simbolo(b.tipo, a, b, false); :}
;


dec_var   ::= VAR variables_list:a PUNTO        {:  RESULT = new DecVar(a, aleft, aright); :}
;
variables_list ::=  variables_list:a var_aux:b        {:  RESULT = a; RESULT.putAll(b);   :}
                |   var_aux:a                                     {:  RESULT = new HashMap<>(); RESULT.putAll(a);   :}
;
var_aux ::= variable:a DOSPUNTOS tipos:b PUNTOCOMA              {:  
                                                                    RESULT = new HashMap<>();
                                                                    RESULT.put(a, b);
                                                                :}
        |   variable:a DOSPUNTOS ARRAY L_LLAVE rango:c R_LLAVE OF tipos:b PUNTOCOMA               {:  RESULT = new HashMap<>(); new DecVarArray(a, b, c, aleft, aright); :}
;
rango ::= ENTERO:a PUNTO PUNTO ENTERO:b           {:  RESULT = new int[]{Integer.parseInt(a), Integer.parseInt(b)}; :}
;

variable    ::= variable:a COMA ID:b         {:  RESULT = a; RESULT.add(b);    :}
            |   ID:a                         {:  RESULT = new LinkedList<>(); RESULT.add(a); :}
;

i_asignar ::= ID:a ASIGNACION expresion:b PUNTOCOMA       {:  RESULT = new AsignacionVar(a, b, aleft, aright);:}
;

expresion ::= e_arit:a       {: RESULT = a; System.out.println("Aritmetica");  :}
            | e_relac:a      {: RESULT = a; System.out.println("Relacional");  :}
            | e_logic:a      {: RESULT = a; System.out.println("Logica");  :}
            | e_nativ:a      {: RESULT = a; System.out.println("Nativo");  :}
            | casteo:a      {: RESULT = a; System.out.println("Casteo");  :}
            | ID:a          {: RESULT = new Acceso (a, aleft, aright);  :}
            | ID:a L_LLAVE expresion:b R_LLAVE  {:  System.out.println("Variable array");   :}
            | L_PAREN expresion:a R_PAREN       {:  RESULT = a; :}
;

e_arit ::= MENOS expresion:a                  {:  RESULT = new Aritmetico(a, OpAritmeticos.NEGACION, aleft, aright); :} %prec UMENOS
        | expresion:a MAS expresion:b        {:  RESULT = new Aritmetico(a, b, OpAritmeticos.SUMA, aleft, aright); :}
        | expresion:a MENOS expresion:b      {:  RESULT = new Aritmetico(a, b, OpAritmeticos.RESTA, aleft, aright); :}
        | expresion:a MULTI expresion:b      {:  RESULT = new Aritmetico(a, b, OpAritmeticos.MULTIPLICACION, aleft, aright); :}
        | expresion:a DIV expresion:b        {:  RESULT = new Aritmetico(a, b, OpAritmeticos.DIVISION, aleft, aright);  :}
;

e_relac ::= expresion:a IGUALA expresion:b     {: System.out.println(a + " es igual a " + b); :}
         | expresion:a DIFERENTEA expresion:b {: System.out.println(a + " es diferente a " + b); :}
         | expresion:a MAYOR expresion:b      {: System.out.println(a + " es mayor que " + b); :}
         | expresion:a MENOR expresion:b      {: System.out.println(a + " es menor que " + b); :}
         | expresion:a MAYORIGUAL expresion:b {: System.out.println(a + " es mayor o igual a " + b); :}
         | expresion:a MENORIGUAL expresion:b {: System.out.println(a + " es menor o igual a " + b); :}
;

e_logic ::= NOT expresion:a                    {: System.out.println("Not " + a); :}
         | expresion:a OR expresion:b         {: System.out.println(a + " o " + b); :}
         | expresion:a AND expresion:b        {: System.out.println(a + " y " + b); :}
;

e_nativ ::= ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(Dato.ENTERO), aleft, aright); System.out.println("Entero");       :}
         | DECIMAL:a     {:   RESULT = new Nativo(Double.parseDouble(a), new Tipo(Dato.DECIMAL), aleft, aright);    :}
         | CADENA:a      {:   RESULT = new Nativo(a, new Tipo(Dato.CADENA), aleft, aright);                         :}
         | CARACTER:a    {:   RESULT = new Nativo(a, new Tipo(Dato.CARACTER), aleft, aright);                       :}
;


